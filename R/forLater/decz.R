decz <- function(x,Z){
  
  #    [y,z] = decz(x,df)
  #	or
  #		[y,Z] = decz(x,Z)
  #		Recursive sampling rate decimator. This is a version of decdc
  #	that can be run iteratively over a long data set, e.g., to
  #decimate an entire recording that is too large to be read into
  #	memory. See wavdec() for a use of this function to decimate an
  #entire WAV format file.
  # The first time decz is called, use the following format:
  #  y = decz(x,df) ; 
  # The subsequent calls to decz for contiguous input data are:
  #	 [y,z] = decz(x,z)
  #The final call when there is no more input data is:
  #	 y = decz([],z)
  #  Each output y in the above contains a segment of the decimated
  #	signal and so these need to be concatenated. See example below.
  
  #	Inputs:
  #		x is a vector or matrix containing the signal(s) to be decimated.
  #    		 If x is a matrix, each column is decimated separately.
  #  		df is the decimation factor. The output sampling rate is the input
  #  		 sampling rate divided by df. df must be an integer greater than 1.
  # 	 df can also be a three element vector in which case:
  #        df(1) is the decimation factor
  #      df(2) is the number of output samples spanned by the filter (default
  # value is 12). A larger value makes the filter steeper.
  #     df(3) is the fractional bandwidth of the filter (default value is 
  #  0.8) relative to the output Nyquist frequency. If df(2) is greater than
  #		  12, df(3) can be closer to 1.
  #		Z is the 'state' structure that is generated by a previous call to
  #		 decz. This is how the function keeps track of filter internal values
  #		 (i.e., memory) from call-to-call.
  #
  #		Returns:
  #		y is the decimated signal vector or matrix. It has the same number
  #	 of columns as x but has, on average, 1/df of the rows.
  #
  #     Decimation is performed in the same way as for decdc. The group delay of the
  #		filter is removed. For large decimation factors (e.g., df>>20), it is better 
  #		to perform several nested decimations with lower factors.
  #
  #		Example:
  #		Assuming you have a function called 'load_next_block' which reads in the next
  #		piece of a contiguous input data stream, decimate as follows:
  #		z = 4 ;					set the decimation factor
  #		Y = [] ;
  #	   x = load_next_block ;
  #		while ~isempty(x),
  # 		  [y,z]=decdc(x,z);
  #		  Y(end+(1:size(y,1)),1:size(y,2)) = y ;
  #		  x = load_next_block ;
  #		end
  # 		y=decdc([],z);
  #		Y(end+(1:size(y,1)),1:size(y,2)) = y ;
  #
  #     Valid: Matlab, Octave
  #     markjohnson@st-andrews.ac.uk
  #     last modified: May 2017
      
  if(!is.data.frame(Z)){
    frbw <- 0.8 
    nf <- 12 
    if (length(Z)>=2){
      nf <- Z[2] 
      if(length(Z)>=3){
        frbw <- Z[3] 
      }
    }
  
  
    df <- Z[1] 
    Z <- data.frame(df = df, z, h) 
    Z$h <- fir1(df*nf,frbw/df) ;
    nh <- length(Z.h) ;
    Z$n <- nh ;
    npre <- floor(nh*0.5) ;
    Z$z <- cbind(2*x[1,]-x[1+seq(from = nh-df-npre, by = -1, to =1),],x[1:npre,]) 
    x <- x[npre+1:end,] ;
  }
  
  nh <- Z$n 
  df <- Z$df 
  if (isempty(x)){
    # reuse the last few inputs to squeeze some more output
    # from the filter.
    x <- 2*Z$z[1,]-apply(Z$z[2:ceil(nh/2),], MARGIN = c(nrow(Z$z), ncol(Z$z)), fun = rev) ;
  }
  for (k in 1:ncol(x)){
    list(X,zz,z) = buffer(x[,k],nh,nh-df,Z$z[,k]) ;#need to write a function or find a function
    if (k==1){
     y = matrix(0,ncol(X),ncol(x)) ;
    }
    y[,k] = t((Z$h*X)) 
    Z$z[,k] <- z 
  }
  return(list(y=y, Z=Z))
}