#' Recursive sampling rate decimator. This is a version of decdc that can be run iteratively over a long data set, e.g., to decimate an entire recording that is too large to be read into memory.
#' 
#' @description The first time decz is called, use the following format: y = decz(x,df). The subsequent calls to decz for contiguous input data are: list(y = y, Z = Z) = decz(x,Z). The final call when there is no more input data is: y = decz(x = NULL, Z = Z). Each output y in the above contains a segment of the decimated signal and so these need to be concatenated.
#' @param x A vector or matrix containing the signal(s) to be decimated. If x is a matrix, each column is decimated separately.
#' @param df The decimation factor. The output sampling rate is the input sampling rate divided by df. df must be an integer greater than 1. df can also be a three element vector in which case: df(1) is the decimation factor; df(2) is the number of output samples spanned by the filter (default value is 12). A larger value makes the filter steeper; df(3) is the fractional bandwidth of the filter (default value is 0.8) relative to the output Nyquist frequency. If df(2) is greater than 12, df(3) can be closer to 1.
#' @param Z The 'state' list that is generated by a previous call to decz. This is how the function keeps track of filter internal values (i.e., memory) from call-to-call.
#' @return y The decimated signal vector or matrix. It has the same number of columns as x but has, on average, 1/df of the rows.
#' @note Decimation is performed in the same way as for decdc. The group delay of the filter is removed. For large decimation factors (e.g., df>>50), it is better to perform several nested decimations with lower factors.

decz <- function(x, Z) {
  nf <- 12          #filter length is nf*df
  frbw <- 0.8        #bandwidth of filter relative to new Nyquist
  if(!is.list(Z)) {
    frbw <- 0.8 
    nf <- 12 
    if (length(Z) >= 2) {
      nf <- Z[2] 
      if (length(Z) >= 3) {
        frbw <- Z[3] 
      }
    }
    df <- Z[1]
    Z <- list()
    Z$h <- signal::fir1((df * nf), (frbw / df)) 
    nh <- length(Z$h) 
    Z$n <- nh
    npre <- floor(df * (nf - 1) / 2 - 1) 
    Z$z <- rbind(2 * x[1, ] - x[(1 + seq(from = (nh - df - npre), by = -1, to = 1)), ], x[1:npre, ]) 
    Z$ov <- c()
    if (is.matrix(x)) {
      x <- x[((npre + 1):nrow(x)), ]
    }
    if (is.vector(x)) {
      x <- x[((npre + 1):length(x)), ]
    }
  }
  nh <- Z$n 
  Z$df <- df
  df <- Z$df 
  if (is.null(x)) {
    x <- rbind(Z$z, Z$ov)
    npre <- floor(df * (nf - 1) / 2 - 1)
    x <- x <- rbind(Z$ov, (2 * x[length(x), ] - x[(length(x) - (1:npre - 1)), ]))
  } else {
    if (!is.null(Z$ov)) {
      x <- rbind(Z$ov, x)
    }
  }
  Z$ov <- c()
  for (k in 1:ncol(x)) {
    listXz <- buffer_opt(x[, k], nh, nh - df, Z$z[, k]) 
    X <- listXz$X
    z <- listXz$z
  }
  y <- matrix(0, ncol(X), ncol(x))
  for (k in 1:ncol(x)) {
    y[, k] <- t((Z$h * X)) 
    Z$z[, k] <- z 
    if (is.null(Z$ov)) {
      Z$ov <- matrix(0, length(zz), ncol(x))
    }
    Z$ov[, k] <- zz
  }
  return(list(y = y, Z = Z))
}