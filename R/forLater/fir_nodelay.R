#The following is an attempt to translate Mark Johnson's fir_nodelay.m matlab script, 
#from the dtag tool box, to an R script.
#note that I made no effort to vectorize or use apply...just changed matlab to R code keeping the same general structure.
# SDR, March 2014

#function    [y,h] = fir_nodelay(x,n,fp,qual)
#
#     [y,h] =fir_nodelay(x,n,fp,qual)
#     n is the length of symmetric FIR filter to use.
#     fp is the filter cut-off frequency relative to fs/2=1
#     qual is an optional qualifier to pass to fir1.
#     The filter is generated by a call to fir1:
  #        h = fir1(n,fp,qual);
#     Optional 2nd output argument returns the filter used.
#  note: (from SDR) x is the signal to be filtered and y is the signal to filter.

fir_nodelay <- function(x,n,fp,qual){
  require(signal) #for filter design, filtering
  #input checking
  if (missing(qual)) qual <- NA
  #make sure x is a column vector
  if (is.vector(x)) x <- as.matrix(x, nrow=length(x))
  if (dim(x)[2] > dim(x)[1]) x <- t(x) #in case of multi-channel data, make sure matrix rows are samples and columns are channels
  
  #generate fir filter
  ifelse(is.na(qual), 
         h <- fir1(n,fp), 
         h <- fir1(n,fp,qual))
  
  #filter the signal
  y = filter(x=rbind(x[seq(from=n, by=-1, to=2), , drop=F],
                     x, 
                     x[nrow(x)+seq(from=-n, to=-2), , drop=F]),
             filt=h) ;
  #change y from a time-series object to a matrix
  y <- as.matrix(y, nrow=nrow(x))
  
  #account for filter offset
  noffs = floor(n/2)
  y = y[n+noffs-1+c(1:nrow(x)), , drop=F]
  
  return(list(y=y, h=h))
  }