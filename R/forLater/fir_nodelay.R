#' Delay-free filtering using a linear-phase (symmetric) FIR filter followed by group delay correction. Delay-free filtering is needed when the relative timing between signals is important e.g., when integrating signals that have been sampled at different rates.
#' 
#' @param x The signal to be filtered. It can be multi-channel with a signal in each column, e.g., an acceleration matrix. The number of samples (i.e., the number of rows in x) must be larger than the filter length, n.
#' @param n The length of symmetric FIR filter to use in units of input samples (i.e., samples of x). The length should be at least 4/fc. A longer filter gives a steeper cut-off.
#' @param fp The filter cut-off frequency relative to fs/2=1. If a single number is given, the filter is a low-pass or high-pass. If fp is a vector with two numbers, the filter is a bandpass filter with lower and upper cut-off frequencies given by fp(1) and fp(2). For a bandpass filter, n should be at least 4/fp(1) or 4/diff(fp) whichever is larger.
#' @param qual An optional qualifier determining if the filter is: low-pass (the default value if fc has a single number), high-pass.
#' @return y The filtered signal with the same size as x.
#' @return h The vector of filter coefficients used by fir_nodelay (a vector).
#' @note The filter is generated by a call to fir1: h <- fir1(n,fp,qual).
#' @note x is the signal to be filtered and y is the signal to filter.
#' @note h is always an odd length filter even if n is even. This is needed to ensure that filter is both symmetric and has a group delay which is an integer number of samples. 
#' @note The filter has a support of n samples, i.e., it uses n samples from x to compute each sample in y. 
#' @note The input samples used are those n/2 samples before to n/2 samples after the sample number being computed. This means that samples at the start and end of the y vector need input samples before the start of x and after the end of x. These are faked by reversing the first n/2 samples of x and concatenating them to the start of x. The same trick is used at the end of x. As a result, the first and last n/2 samples in y are untrustworthy. This initial condition problem is true for any filter but the FIR filter used here makes it easy to identify precisely which samples are unreliable.
#' @example Make a waveform with two harmonics - one at 1/20 and another at 1/4 of the sampling rate.
#'          x <- sin(t(2 * pi * 0.05 * (1:100))+t(cos(2 * pi * 0.25 * (1:100))
#'          y <- fir_nodelay(x, 30, 0.2)
#'          plot(x,y)
#' Returns: The input signal has the first and fifth harmonic. Applying the low-pass filter removes most of the fifth harmonic so the output appears as a sinewave except for the first few samples which are affected by the filter startup transient.
#'          

fir_nodelay <- function(x,n,fp,qual){
  require(signal) #for filter design, filtering
  #input checking
  if (missing(qual)) qual <- NA
  #make sure x is a column vector
  if (is.vector(x)) x <- as.matrix(x, nrow=length(x))
  if (dim(x)[2] > dim(x)[1]) x <- t(x) #in case of multi-channel data, make sure matrix rows are samples and columns are channels
  
  #generate fir filter
  ifelse(is.na(qual), 
         h <- fir1(n,fp), 
         h <- fir1(n,fp,qual))
  
  #filter the signal
  y = filter(x=rbind(x[seq(from=n, by=-1, to=2), , drop=F],
                     x, 
                     x[nrow(x)+seq(from=-n, to=-2), , drop=F]),
             filt=h) ;
  #change y from a time-series object to a matrix
  y <- as.matrix(y, nrow=nrow(x))
  
  #account for filter offset
  noffs = floor(n/2)
  y = y[n+noffs-1+c(1:nrow(x)), , drop=F]
  
  return(list(y=y, h=h))
  }